from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QMenu, QAction
from mywin import Ui_mainWindow
from PyQt5.QtCore import Qt, QPoint, QTimer, QThread, pyqtSignal
from PyQt5.QtGui import QImage, QPixmap, QPainter, QIcon

import sys
import os
import json
import numpy as np
import torch
import torch.backends.cudnn as cudnn
import os
import time
import cv2

from models.experimental import attempt_load
from utils.datasets import LoadImages, LoadWebcam
from utils.CustomMessageBox import MessageBox
from utils.general import check_img_size, check_requirements, check_imshow, colorstr, non_max_suppression, \
    apply_classifier, scale_coords, xyxy2xywh, strip_optimizer, set_logging, increment_path
# from utils.plots import colors, plot_one_box, plot_one_box_PIL
from utils.plots import Annotator, colors, save_one_box

from utils.torch_utils import select_device
from utils.capnums import Camera
from dialog.rtsp_win import Window



from main0 import Count_num
from main import *




class DetThread(QThread):
    send_img = pyqtSignal(np.ndarray)
    send_raw = pyqtSignal(np.ndarray)
    send_statistic = pyqtSignal(dict)
    # emit：detecting/pause/stop/finished/error msg
    send_msg = pyqtSignal(str)
    send_percent = pyqtSignal(int)
    send_fps = pyqtSignal(str)
    send_object = pyqtSignal(str)

    def __init__(self):
        super(DetThread, self).__init__()
        self.weights = './yolov5s.pt'
        self.current_weight = './yolov5s.pt'
        # self.weights = './车辆检测'
        # self.current_weight = './车辆检测'
        self.source = '0'
        self.conf_thres = 0.25
        self.iou_thres = 0.45
        self.jump_out = False                   # jump out of the loop
        self.is_continue = True                 # continue/pause
        self.percent_length = 1000              # progress bar
        self.rate_check = True                  # Whether to enable delay
        self.rate = 100
        self.save_fold = './result'
        # self.send_object = './result'
        self.currentID = '所有对象'
        self.ID = '所有对象'

    @torch.no_grad()
    def run(self,
            imgsz=640,  # inference size (pixels)
            max_det=1000,  # maximum detections per image
            device='',  # cuda device, i.e. 0 or 0,1,2,3 or cpu
            view_img=True,  # show results
            save_txt=False,  # save results to *.txt
            save_conf=False,  # save confidences in --save-txt labels
            save_crop=False,  # save cropped prediction boxes
            nosave=False,  # do not save images/videos
            classes=None,  # filter by class: --class 0, or --class 0 2 3
            agnostic_nms=False,  # class-agnostic NMS
            augment=False,  # augmented inference
            visualize=False,  # visualize features
            update=False,  # update all models
            project='runs/detect',  # save results to project/name
            name='exp',  # save results to project/name
            exist_ok=False,  # existing project/name ok, do not increment
            line_thickness=3,  # bounding box thickness (pixels)
            hide_labels=False,  # hide labels
            hide_conf=False,  # hide confidences
            half=False,  # use FP16 half-precision inference
            ):

        # Initialize
        try:
            device = select_device(device)
            half &= device.type != 'cpu'  # half precision only supported on CUDA
            if self.weights == "./pt/车辆检测":


                # self.send_raw.connect(lambda x: self.show_image(x, self.raw_video))
                # self.send_img.connect(lambda x: self.show_image(x, self.out_video))
                self.road = self.source
                # img = cv2.imread(self.road)
                # self.send_raw.emit(img)
                # self.send_img.emit(img)




                # Count_num(self.road,self.send_raw,self.send_img,self.is_continue)
                self.send_msg.emit('Wating!')
                count_speed(self.road)
                # time.sleep(5)
                self.send_msg.emit('Ready!')
                self.is_continue = False

                # 打开视频
                capture = cv2.VideoCapture(self.road)
                # 读取视频帧数
                fps_num = int(capture.get(cv2.CAP_PROP_FRAME_COUNT))
                # self.rate
                # print(self.rate)
                # set_fps = self.rate #5
                # self.send_fps.emit('fps：'+str(set_fps))
                self.i = 1
                while True:
                    set_fps = self.rate  # 5
                    # print(set_fps)
                    self.send_fps.emit('fps：' + str(set_fps))
                    if self.rate_check:
                        time.sleep(1 / self.rate)

                    if self.jump_out:
                        # self.vid_cap.release()
                        self.send_percent.emit(0)
                        self.send_msg.emit('Stop')
                        if hasattr(self, 'out'):
                            self.out.release()
                        break
                    # 读取每帧图片
                    _, im = capture.read()
                    if im is None:
                        self.send_percent.emit(0)
                        self.send_msg.emit('finished')
                        if hasattr(self, 'out'):
                            self.out.release()
                        break
                    if not self.is_continue:
                        file = "./result/num_"+str(self.i - 1)+".txt"
                        self.send_object.emit(file)
                        # print('IIIIIII: ',self.i)

                        if self.ID == '所有对象':
                            if self.i < 4:
                                names = ['前向流量', '反向流量', '汽车数量', '卡车数量', '公交数量']
                                statistic_dic = {name: 'None' for name in names}
                                self.send_statistic.emit(statistic_dic)

                            else:
                                names = ['前向流量', '反向流量', '汽车数量', '卡车数量', '公交数量']
                                statistic_dic = {name: 0 for name in names}
                                data = []
                                try:
                                    with open("./result/demo_" + str(self.i - 1) + ".txt", 'r') as file:
                                        # 读取文本内容并按行保存在列表中
                                        lines = file.readlines()
                                    for line in lines:  # 使用for循环从列表中读取文件内容
                                        text = line.rstrip()
                                        text_list = text.split('\t')
                                        data.append(text_list[1])  # 将文件内容存入列表并删除掉末尾的空白
                                    statistic_dic['前向流量'] = data[0]
                                    statistic_dic['反向流量'] = data[1]
                                    statistic_dic['汽车数量'] = data[2]
                                    statistic_dic['卡车数量'] = data[3]
                                    statistic_dic['公交数量'] = data[4]

                                except Exception as e:
                                    print("未找到指定文件！")
                                self.send_statistic.emit(statistic_dic)
                        # names = ['车型','速度','车牌']
                        # statistic_dic = {name: 0 for name in names}
                        #
                        # if self.ID == '所有对象':
                        #
                        #     self.send_statistic.emit(statistic_dic)
                        # else:
                        #
                        #     self.send_statistic.emit(statistic_dic)


                    while not self.is_continue:  # 只要 is_continue 变量为 False 就继续等待
                        # file = "./result/num.txt"
                        # self.send_object.emit(file)
                        if self.ID != self.currentID:
                            if self.currentID == '所有对象':
                                names = ['前向流量', '反向流量', '汽车数量', '卡车数量', '公交数量']
                                statistic_dic = {name: 0 for name in names}
                                data = []
                                try:
                                    with open("./result/demo_"+str(self.i - 1)+".txt", 'r') as file:
                                        # 读取文本内容并按行保存在列表中
                                        lines = file.readlines()
                                    for line in lines:  # 使用for循环从列表中读取文件内容
                                        text = line.rstrip()
                                        text_list = text.split('\t')
                                        data.append(text_list[1])  # 将文件内容存入列表并删除掉末尾的空白
                                    statistic_dic['前向流量'] = data[0]
                                    statistic_dic['反向流量'] = data[1]
                                    statistic_dic['汽车数量'] = data[2]
                                    statistic_dic['卡车数量'] = data[3]
                                    statistic_dic['公交数量'] = data[4]

                                except Exception as e:
                                    print("未找到指定文件！")
                                self.send_statistic.emit(statistic_dic)

                            else:
                                ID_num = int(self.currentID[2])
                                # print("DDDDD: ",ID_num)
                                names = ['类型', '速度', '车牌', '可信度']
                                statistic_dic = {name: 'None' for name in names}
                                data = []
                                try:
                                    with open("./result/num_"+str(self.i - 1)+".txt", 'r') as file:
                                        # 读取文本内容并按行保存在列表中
                                        lines = file.readlines()
                                    for line in lines:  # 使用for循环从列表中读取文件内容
                                        text = line.rstrip()
                                        text_list = text.split('\t')
                                        data.append(text_list)  # 将文件内容存入列表并删除掉末尾的空白
                                    statistic_dic['类型'] = data[ID_num][1]
                                    statistic_dic['速度'] = data[ID_num][2] + 'km/h'
                                    if data[ID_num][3] != 0:
                                        statistic_dic['车牌'] = data[ID_num][3]
                                        statistic_dic['可信度'] = data[ID_num][4]

                                except Exception as e:
                                    print("未找到指定文件！")
                                self.send_statistic.emit(statistic_dic)

                            # elif self.currentID == 'ID2':
                            #     names = ['车型', '速度', '车牌']
                            #     statistic_dic = {name: 2 for name in names}
                            #     self.send_statistic.emit(statistic_dic)
                            #
                            # else:
                            #     names = ['车型', '速度', '车牌']
                            #     statistic_dic = {name: 1 for name in names}
                            #     self.send_statistic.emit(statistic_dic)
                            self.ID = self.currentID

                        print("等待 2 秒钟后再次检查 is_continue 的值")
                        time.sleep(2)  # 暂停 2 秒钟
                        if self.is_continue:
                            # 如果 is_continue 变量为 True，就跳出循环，执行程序代码
                            break
                    demo = cv2.imread("./result/demo_"+str(self.i)+".jpg")
                    self.send_raw.emit(im)
                    self.send_img.emit(demo)
                    time.sleep(1/set_fps)

                    # 进度显示
                    percent = int((self.i / fps_num) * self.percent_length)
                    if percent == self.percent_length:
                        # print(count)
                        self.send_percent.emit(0)
                        self.send_msg.emit('finished')
                        if hasattr(self, 'out'):
                            self.out.release()
                        break
                    else:
                        self.send_percent.emit(percent)

                    self.i = self.i + 1

                    # if percent == self.percent_length:
                    #     # print(count)
                    #     self.send_percent.emit(0)
                    #     self.send_msg.emit('finished')
                    #     if hasattr(self, 'out'):
                    #         self.out.release()
                    #     break

                self.is_continue = False
                # 将Python的工作目录设置回原目录
                # os.chdir(original_dir)

            else:
                # Load model
                model = attempt_load(self.weights, map_location=device)  # load FP32 model
                num_params = 0
                for param in model.parameters():
                    num_params += param.numel()
                stride = int(model.stride.max())  # model stride
                imgsz = check_img_size(imgsz, s=stride)  # check image size
                names = model.module.names if hasattr(model, 'module') else model.names  # get class names
                if half:
                    model.half()  # to FP16

                # Dataloader
                if self.source.isnumeric() or self.source.lower().startswith(('rtsp://', 'rtmp://', 'http://', 'https://')):
                    view_img = check_imshow()
                    cudnn.benchmark = True  # set True to speed up constant image size inference
                    dataset = LoadWebcam(self.source, img_size=imgsz, stride=stride)
                    # bs = len(dataset)  # batch_size
                else:
                    dataset = LoadImages(self.source, img_size=imgsz, stride=stride)

                # Run inference
                if device.type != 'cpu':
                    model(torch.zeros(1, 3, imgsz, imgsz).to(device).type_as(next(model.parameters())))  # run once
                count = 0
                jump_count = 0
                start_time = time.time()
                dataset = iter(dataset)

                while True:
                    if self.jump_out:
                        self.vid_cap.release()
                        self.send_percent.emit(0)
                        self.send_msg.emit('Stop')
                        if hasattr(self, 'out'):
                            self.out.release()
                        break
                    # change model
                    if self.current_weight != self.weights:
                        # Load model
                        model = attempt_load(self.weights, map_location=device)  # load FP32 model
                        num_params = 0
                        for param in model.parameters():
                            num_params += param.numel()
                        stride = int(model.stride.max())  # model stride
                        imgsz = check_img_size(imgsz, s=stride)  # check image size
                        names = model.module.names if hasattr(model, 'module') else model.names  # get class names
                        if half:
                            model.half()  # to FP16
                        # Run inference
                        if device.type != 'cpu':
                            model(torch.zeros(1, 3, imgsz, imgsz).to(device).type_as(next(model.parameters())))  # run once
                        self.current_weight = self.weights
                    if self.is_continue:
                        path, img, im0s, self.vid_cap = next(dataset)
                        # jump_count += 1
                        # if jump_count % 5 != 0:
                        #     continue
                        count += 1
                        if count % 30 == 0 and count >= 30:
                            fps = int(30/(time.time()-start_time))
                            self.send_fps.emit('fps：'+str(fps))
                            start_time = time.time()
                        if self.vid_cap:
                            percent = int(count/self.vid_cap.get(cv2.CAP_PROP_FRAME_COUNT)*self.percent_length)
                            self.send_percent.emit(percent)
                        else:
                            percent = self.percent_length

                        statistic_dic = {name: 0 for name in names}
                        img = torch.from_numpy(img).to(device)
                        img = img.half() if half else img.float()  # uint8 to fp16/32
                        img /= 255.0  # 0 - 255 to 0.0 - 1.0
                        if img.ndimension() == 3:
                            img = img.unsqueeze(0)

                        pred = model(img, augment=augment)[0]

                        # Apply NMS
                        pred = non_max_suppression(pred, self.conf_thres, self.iou_thres, classes, agnostic_nms, max_det=max_det)
                        # Process detections
                        for i, det in enumerate(pred):  # detections per image
                            im0 = im0s.copy()
                            annotator = Annotator(im0, line_width=line_thickness, example=str(names))
                            if len(det):
                                # Rescale boxes from img_size to im0 size
                                det[:, :4] = scale_coords(img.shape[2:], det[:, :4], im0.shape).round()

                                # Write results
                                for *xyxy, conf, cls in reversed(det):
                                    c = int(cls)  # integer class
                                    statistic_dic[names[c]] += 1
                                    label = None if hide_labels else (names[c] if hide_conf else f'{names[c]} {conf:.2f}')
                                    annotator.box_label(xyxy, label, color=colors(c, True))

                        if self.rate_check:
                            time.sleep(1/self.rate)
                        im0 = annotator.result()
                        self.send_img.emit(im0)
                        self.send_raw.emit(im0s if isinstance(im0s, np.ndarray) else im0s[0])
                        self.send_statistic.emit(statistic_dic)
                        if self.save_fold:
                            os.makedirs(self.save_fold, exist_ok=True)
                            if self.vid_cap is None:
                                save_path = os.path.join(self.save_fold,
                                                         time.strftime('%Y_%m_%d_%H_%M_%S',
                                                                       time.localtime()) + '.jpg')
                                cv2.imwrite(save_path, im0)
                            else:
                                if count == 1:
                                    ori_fps = int(self.vid_cap.get(cv2.CAP_PROP_FPS))
                                    if ori_fps == 0:
                                        ori_fps = 25
                                    # width = int(self.vid_cap.get(cv2.CAP_PROP_FRAME_WIDTH))
                                    # height = int(self.vid_cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
                                    width, height = im0.shape[1], im0.shape[0]
                                    save_path = os.path.join(self.save_fold, time.strftime('%Y_%m_%d_%H_%M_%S', time.localtime()) + '.mp4')
                                    self.out = cv2.VideoWriter(save_path, cv2.VideoWriter_fourcc(*"mp4v"), ori_fps,
                                                               (width, height))
                                self.out.write(im0)
                        if percent == self.percent_length:
                            print(count)
                            self.send_percent.emit(0)
                            self.send_msg.emit('finished')
                            if hasattr(self, 'out'):
                                self.out.release()
                            break

        except Exception as e:
            self.send_msg.emit('%s' % e)



class MainWindow(QMainWindow, Ui_mainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)
        self.setupUi(self)
        self.m_flag = False

        # style 1: window can be stretched
        # self.setWindowFlags(Qt.CustomizeWindowHint | Qt.WindowStaysOnTopHint)

        # style 2: window can not be stretched
        self.setWindowFlags(Qt.Window | Qt.FramelessWindowHint
                            | Qt.WindowSystemMenuHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint)
        # self.setWindowOpacity(0.85)  # Transparency of window

        self.minButton.clicked.connect(self.showMinimized)
        self.maxButton.clicked.connect(self.max_or_restore)
        # show Maximized window
        self.maxButton.animateClick(10)
        self.closeButton.clicked.connect(self.close)

        self.qtimer = QTimer(self)
        self.qtimer.setSingleShot(True)
        self.qtimer.timeout.connect(lambda: self.statistic_label.clear())

        # search models automatically
        self.comboBox.clear()
        self.pt_list = os.listdir('./pt')
        self.pt_list = [file for file in self.pt_list if file.endswith('.pt')]
        self.pt_list.sort(key=lambda x: os.path.getsize('./pt/'+x))
        self.comboBox.clear()
        self.comboBox.addItems(self.pt_list)
        self.ob_list = ["所有对象"]
        self.comboBox_2.clear()
        self.comboBox_2.addItems((self.ob_list))
        self.qtimer_search = QTimer(self)
        self.qtimer_search.timeout.connect(lambda: self.search_pt())
        self.qtimer_search.start(2000)

        # yolov5 thread
        self.det_thread = DetThread()
        self.model_type = self.comboBox.currentText()
        # if self.model_type == "Count_Num":
        self.ID = self.comboBox_2.currentText()

        # else:
        self.det_thread.weights = "./pt/%s" % self.model_type
        self.det_thread.source = '0'
        self.det_thread.percent_length = self.progressBar.maximum()
        self.det_thread.send_raw.connect(lambda x: self.show_image(x, self.raw_video))
        self.det_thread.send_img.connect(lambda x: self.show_image(x, self.out_video))
        self.det_thread.send_statistic.connect(self.show_statistic)
        self.det_thread.send_msg.connect(lambda x: self.show_msg(x))
        self.det_thread.send_percent.connect(lambda x: self.progressBar.setValue(x))
        self.det_thread.send_fps.connect(lambda x: self.fps_label.setText(x))
        self.det_thread.send_object.connect(lambda x: self.Addobject(x))

        self.fileButton.clicked.connect(self.open_file)
        self.cameraButton.clicked.connect(self.chose_cam)
        self.rtspButton.clicked.connect(self.chose_rtsp)

        self.runButton.clicked.connect(self.run_or_continue)
        self.stopButton.clicked.connect(self.stop)

        self.comboBox.currentTextChanged.connect(self.change_model)
        self.comboBox_2.currentTextChanged.connect((self.change_ob))
        self.confSpinBox.valueChanged.connect(lambda x: self.change_val(x, 'confSpinBox'))
        self.confSlider.valueChanged.connect(lambda x: self.change_val(x, 'confSlider'))
        self.iouSpinBox.valueChanged.connect(lambda x: self.change_val(x, 'iouSpinBox'))
        self.iouSlider.valueChanged.connect(lambda x: self.change_val(x, 'iouSlider'))
        self.rateSpinBox.valueChanged.connect(lambda x: self.change_val(x, 'rateSpinBox'))
        self.rateSlider.valueChanged.connect(lambda x: self.change_val(x, 'rateSlider'))

        self.checkBox.clicked.connect(self.checkrate)
        self.saveCheckBox.clicked.connect(self.is_save)
        self.load_setting()

    def Addobject(self, x):
        try:
            ob_list = ['所有对象']
            # data = []
            with open(x, 'r') as file:
                # 读取文本内容并按行保存在列表中
                lines = file.readlines()
            for line in lines[1:]:  # 使用for循环从列表中读取文件内容
                text = line.rstrip()
                text_list = text.split('\t')
                # data.append(text_list[0])  # 将文件内容存入列表并删除掉末尾的空白
                ob_list.append(text_list[0])  # 将文件内容存入列表并删除掉末尾的空白
            # with open(x, 'r') as file:
            #     # 读取文本内容并按行保存在列表中
            #     lines = file.readlines()
            # ob_list = ['所有对象']
            # for line in lines:
            #     ob_list.append(line)
            # print(ob_list)
            # L = len(lines)
            L = len(ob_list)
            # for i in range(0, L):
            #     ob_list.append(data[i])
            # print(ob_list)
            self.comboBox_2.clear()
            self.comboBox_2.setCurrentIndex(L)
            # self.comboBox.addItems(['1','2'])
            self.comboBox_2.addItems(ob_list)
            # ID = self.comboBox_2.currentText()
            # self.det_thread.currentID = ID
        except Exception as e:
            print("指定文件不存在！")
            self.statistic_msg('%s' % e)


    def search_pt(self):
        pt_list = os.listdir('./pt')
        pt_list = [file for file in pt_list if file.endswith('.pt')]
        pt_list.sort(key=lambda x: os.path.getsize('./pt/' + x))
        pt_list.append("车辆检测")
        if pt_list != self.pt_list:
            self.pt_list = pt_list
            self.comboBox.clear()
            self.comboBox.addItems(self.pt_list)

    def is_save(self):
        if self.saveCheckBox.isChecked():
            self.det_thread.save_fold = './result'
        else:
            self.det_thread.save_fold = None

    def checkrate(self):
        if self.checkBox.isChecked():
            self.det_thread.rate_check = True
        else:
            self.det_thread.rate_check = False

    def chose_rtsp(self):
        self.rtsp_window = Window()
        config_file = 'config/ip.json'
        if not os.path.exists(config_file):
            ip = "rtsp://admin:admin888@192.168.1.67:555"
            new_config = {"ip": ip}
            new_json = json.dumps(new_config, ensure_ascii=False, indent=2)
            with open(config_file, 'w', encoding='utf-8') as f:
                f.write(new_json)
        else:
            config = json.load(open(config_file, 'r', encoding='utf-8'))
            ip = config['ip']
        self.rtsp_window.rtspEdit.setText(ip)
        self.rtsp_window.show()
        self.rtsp_window.rtspButton.clicked.connect(lambda: self.load_rtsp(self.rtsp_window.rtspEdit.text()))

    def load_rtsp(self, ip):
        try:
            self.stop()
            MessageBox(
                self.closeButton, title='Tips', text='Loading rtsp stream', time=1000, auto=True).exec_()
            self.det_thread.source = ip
            new_config = {"ip": ip}
            new_json = json.dumps(new_config, ensure_ascii=False, indent=2)
            with open('config/ip.json', 'w', encoding='utf-8') as f:
                f.write(new_json)
            self.statistic_msg('Loading rtsp：{}'.format(ip))
            self.rtsp_window.close()
        except Exception as e:
            self.statistic_msg('%s' % e)

    def chose_cam(self):
        try:
            self.stop()
            MessageBox(
                self.closeButton, title='Tips', text='Loading camera', time=2000, auto=True).exec_()
            # get the number of local cameras
            _, cams = Camera().get_cam_num()
            popMenu = QMenu()
            popMenu.setFixedWidth(self.cameraButton.width())
            popMenu.setStyleSheet('''
                                            QMenu {
                                            font-size: 16px;
                                            font-family: "Microsoft YaHei UI";
                                            font-weight: light;
                                            color:white;
                                            padding-left: 5px;
                                            padding-right: 5px;
                                            padding-top: 4px;
                                            padding-bottom: 4px;
                                            border-style: solid;
                                            border-width: 0px;
                                            border-color: rgba(255, 255, 255, 255);
                                            border-radius: 3px;
                                            background-color: rgba(200, 200, 200,50);}
                                            ''')

            for cam in cams:
                exec("action_%s = QAction('%s')" % (cam, cam))
                exec("popMenu.addAction(action_%s)" % cam)

            x = self.groupBox_5.mapToGlobal(self.cameraButton.pos()).x()
            y = self.groupBox_5.mapToGlobal(self.cameraButton.pos()).y()
            y = y + self.cameraButton.frameGeometry().height()
            pos = QPoint(x, y)
            action = popMenu.exec_(pos)
            if action:
                self.det_thread.source = action.text()
                self.statistic_msg('Loading camera：{}'.format(action.text()))
        except Exception as e:
            self.statistic_msg('%s' % e)

    def load_setting(self):
        config_file = 'config/setting.json'
        if not os.path.exists(config_file):
            iou = 0.26
            conf = 0.33
            rate = 10
            check = 0
            savecheck = 0
            new_config = {"iou": iou,
                          "conf": conf,
                          "rate": rate,
                          "check": check,
                          "savecheck": savecheck
                          }
            new_json = json.dumps(new_config, ensure_ascii=False, indent=2)
            with open(config_file, 'w', encoding='utf-8') as f:
                f.write(new_json)
        else:
            config = json.load(open(config_file, 'r', encoding='utf-8'))
            if len(config) != 5:
                iou = 0.26
                conf = 0.33
                rate = 10
                check = 0
                savecheck = 0
            else:
                iou = config['iou']
                conf = config['conf']
                rate = config['rate']
                check = config['check']
                savecheck = config['savecheck']
        self.confSpinBox.setValue(iou)
        self.iouSpinBox.setValue(conf)
        self.rateSpinBox.setValue(rate)
        self.checkBox.setCheckState(check)
        self.det_thread.rate_check = check
        self.saveCheckBox.setCheckState(savecheck)
        self.is_save()

    def change_val(self, x, flag):
        if flag == 'confSpinBox':
            self.confSlider.setValue(int(x*100))
        elif flag == 'confSlider':
            self.confSpinBox.setValue(x/100)
            self.det_thread.conf_thres = x/100
        elif flag == 'iouSpinBox':
            self.iouSlider.setValue(int(x*100))
        elif flag == 'iouSlider':
            self.iouSpinBox.setValue(x/100)
            self.det_thread.iou_thres = x/100
        elif flag == 'rateSpinBox':
            self.rateSlider.setValue(x)
        elif flag == 'rateSlider':
            self.rateSpinBox.setValue(x)
            self.det_thread.rate = x * 10
        else:
            pass

    def statistic_msg(self, msg):
        self.statistic_label.setText(msg)
        # self.qtimer.start(3000)

    def show_msg(self, msg):
        self.runButton.setChecked(Qt.Unchecked)
        self.statistic_msg(msg)
        if msg == "Finished":
            self.saveCheckBox.setEnabled(True)

    def change_model(self, x):
        self.model_type = self.comboBox.currentText()
        self.det_thread.weights = "./pt/%s" % self.model_type
        self.statistic_msg('Change model to %s' % x)

    def change_ob(self, x):
        self.ID = self.comboBox_2.currentText()
        self.det_thread.currentID = self.ID
        self.statistic_msg('Pause! Current object is %s' % x)

    def open_file(self):

        config_file = 'config/fold.json'
        # config = json.load(open(config_file, 'r', encoding='utf-8'))
        config = json.load(open(config_file, 'r', encoding='utf-8'))
        open_fold = config['open_fold']
        if not os.path.exists(open_fold):
            open_fold = os.getcwd()
        name, _ = QFileDialog.getOpenFileName(self, 'Video/image', open_fold, "Pic File(*.mp4 *.mkv *.avi *.flv "
                                                                          "*.jpg *.png)")
        if name:
            self.det_thread.source = name
            self.statistic_msg('Loaded file：{}'.format(os.path.basename(name)))
            config['open_fold'] = os.path.dirname(name)
            config_json = json.dumps(config, ensure_ascii=False, indent=2)
            with open(config_file, 'w', encoding='utf-8') as f:
                f.write(config_json)
            self.stop()

    def max_or_restore(self):
        if self.maxButton.isChecked():
            self.showMaximized()
        else:
            self.showNormal()

    def run_or_continue(self):
        self.det_thread.jump_out = False
        if self.runButton.isChecked():
            self.saveCheckBox.setEnabled(False)
            self.det_thread.is_continue = True
            if not self.det_thread.isRunning():
                self.det_thread.start()
            source = os.path.basename(self.det_thread.source)
            source = 'camera' if source.isnumeric() else source
            self.statistic_msg('Detecting >> model：{}，file：{}'.
                               format(os.path.basename(self.det_thread.weights),
                                      source))
        else:
            self.det_thread.is_continue = False
            self.statistic_msg('Pause')

    def stop(self):
        self.det_thread.jump_out = True
        self.saveCheckBox.setEnabled(True)

    def mousePressEvent(self, event):
        self.m_Position = event.pos()
        if event.button() == Qt.LeftButton:
            if 0 < self.m_Position.x() < self.groupBox.pos().x() + self.groupBox.width() and \
                    0 < self.m_Position.y() < self.groupBox.pos().y() + self.groupBox.height():
                self.m_flag = True

    def mouseMoveEvent(self, QMouseEvent):
        if Qt.LeftButton and self.m_flag:
            self.move(QMouseEvent.globalPos() - self.m_Position)

    def mouseReleaseEvent(self, QMouseEvent):
        self.m_flag = False

    @staticmethod
    def show_image(img_src, label):
        try:
            ih, iw, _ = img_src.shape
            w = label.geometry().width()
            h = label.geometry().height()
            # keep original aspect ratio
            if iw/w > ih/h:
                scal = w / iw
                nw = w
                nh = int(scal * ih)
                img_src_ = cv2.resize(img_src, (nw, nh))

            else:
                scal = h / ih
                nw = int(scal * iw)
                nh = h
                img_src_ = cv2.resize(img_src, (nw, nh))

            frame = cv2.cvtColor(img_src_, cv2.COLOR_BGR2RGB)
            img = QImage(frame.data, frame.shape[1], frame.shape[0], frame.shape[2] * frame.shape[1],
                         QImage.Format_RGB888)
            label.setPixmap(QPixmap.fromImage(img))

        except Exception as e:
            print(repr(e))

    def show_statistic(self, statistic_dic):
        try:
            self.resultWidget.clear()
            statistic_dic = sorted(statistic_dic.items(), key=lambda x: x[1], reverse=True)
            # statistic_dic = [i for i in statistic_dic if i[1] > 0]
            statistic_dic = [i for i in statistic_dic]
            results = [' '+str(i[0]) + '：' + str(i[1]) for i in statistic_dic]
            self.resultWidget.addItems(results)

        except Exception as e:
            print(repr(e))

    def closeEvent(self, event):
        self.det_thread.jump_out = True
        config_file = 'config/setting.json'
        config = dict()
        config['iou'] = self.confSpinBox.value()
        config['conf'] = self.iouSpinBox.value()
        config['rate'] = self.rateSpinBox.value()
        config['check'] = self.checkBox.checkState()
        config['savecheck'] = self.saveCheckBox.checkState()
        config_json = json.dumps(config, ensure_ascii=False, indent=2)
        with open(config_file, 'w', encoding='utf-8') as f:
            f.write(config_json)
        MessageBox(
            self.closeButton, title='Tips', text='Closing the program', time=2000, auto=True).exec_()
        sys.exit(0)


if __name__ == "__main__":

    # from unbox_yolov5_deepsort_counting.main import *
    # from unbox_yolov5_deepsort_counting.tracker import *
    # 将tracker的路径添加到系统路径中
    # tracker_path = os.path.join(os.path.dirname(__file__), 'unbox_yolov5_deepsort_counting/tracker')
    # sys.path.append(tracker_path)
    # from unbox_yolov5_deepsort_counting import tracker
    # sys.path.append('E:/深度学习/pyqt5/GUI/unbox_yolov5_deepsort_counting/')
    # sys.path.append('E:/深度学习/pyqt5/GUI/unbox_yolov5_deepsort_counting/deep_sort/')
    # from main import Count_num

    # list_blue = []
    # list_yellow = []
    app = QApplication(sys.argv)
    myWin = MainWindow()
    myWin.show()
    # myWin.showMaximized()
    sys.exit(app.exec_())
